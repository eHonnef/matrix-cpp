/***************************************************************************************************
 *
 ***************************************************************************************************/
#ifndef P_DELETE_H
#define P_DELETE_H
/***************************************************************************************************
 *
 ***************************************************************************************************/
namespace Utils {
template <typename U> inline void pDelete(U *&pointer) {
  if (pointer) {
    delete pointer;
    pointer = nullptr;
  }
}
template <typename U> inline void pDelete(U pointer) { return; }
} // namespace Utils
#endif // P_DELETE_H
/***************************************************************************************************
 *
 ***************************************************************************************************/
#ifndef MATRIX_H
#define MATRIX_H
/***************************************************************************************************
 *
 ***************************************************************************************************/
#include <cstring>
#include <exception>
#include <iomanip>
#include <iostream>
#include <ostream>
#include <sstream>
#include <string>
#include <typeinfo>
/***************************************************************************************************
 *
 ***************************************************************************************************/
template <class T> class Matrix {
public:
  Matrix(unsigned rows, unsigned cols, T init_val = T()) {
    _rows = rows;
    _cols = cols;
    alloc_init();

    fill(init_val);
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  Matrix(const std::initializer_list<std::initializer_list<T>> &init) {
    _rows = init.size();
    _cols = init.begin()->size();
    alloc_init();

    unsigned row = 0;
    unsigned col = 0;
    for (const auto &it_r : init) {
      if (it_r.size() != _cols)
        throw std::runtime_error("The row <" + std::to_string(row) +
                                 "> has more/less columns than the others.");
      for (const auto &it_c : it_r)
        _matrix[row][col++] = it_c;

      col = 0;
      row += 1;
    }
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  ~Matrix() { dealloc(); }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  std::string to_string() const {
    std::ostringstream ss;
    ss << *this;
    return ss.str();
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  unsigned rows() const { return _rows; }
  unsigned cols() const { return _cols; }
  unsigned size() const { return _rows * _cols; }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  T *operator[](unsigned index) { return _matrix[index]; }
  T *operator[](unsigned index) const { return _matrix[index]; }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  T &at(unsigned row, unsigned col) {
    if (row >= _rows || col >= _cols)
      throw std::out_of_range("Out of bound");

    return _matrix[row][col];
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  T &at(unsigned row, unsigned col) const {
    if (row >= _rows || col >= _cols)
      throw std::out_of_range("Out of bound");

    return _matrix[row][col];
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  Matrix &operator=(const Matrix &m) {
    //@todo
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  Matrix &operator+=(const Matrix &m) {
    //@todo
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  Matrix &operator-=(const Matrix &m) {
    //@todo
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  Matrix &operator*=(const Matrix &m) {
    //@todo
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  Matrix &operator*=(const T &value) {
    //@todo
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  Matrix &operator/=(const T &value) {
    //@todo
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  bool operator==(const Matrix &m) const {
    if (m.rows() != _rows)
      return false;
    else if (m.cols() != _cols)
      return false;

    for (auto i = _rows; i-- > 0;)
      for (auto j = _cols; j-- > 0;)
        if (m[i][j] != _matrix[i][j])
          return false;

    return true;
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  bool operator!=(const Matrix &m) const { return !(*this == m); }
  const Matrix &operator+(const Matrix &m) { return (*this += m); }
  const Matrix &operator-(const Matrix &m) { return (*this -= m); }
  const Matrix &operator*(const Matrix &m) { return (*this *= m); }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  void fill(const T &value) {
    for (auto i = _rows; i-- > 0;)
      for (auto j = _cols; j-- > 0;)
        _matrix[i][j] = value;
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  void print() {
    std::cout << "Rows: " << _rows << std::endl;
    std::cout << "Cols: " << _cols << std::endl;

    for (unsigned i = 0; i < _rows; i++) {
      std::cout << std::setw(3);
      for (unsigned j = 0; j < _cols; j++)
        std::cout << _matrix[i][j] << std::setw(3);

      std::cout << std::endl;
    }
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  Matrix transpose() {
    Matrix<T> rtn(_cols, _rows);

    for (auto i = _rows; i-- > 0;)
      for (auto j = _cols; j-- > 0;)
        rtn[j][i] = _matrix[i][j];

    return rtn;
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  void remove_row(unsigned row) {
    if (row >= _rows)
      throw std::out_of_range("row is out of bound.");

    delete[] _matrix[row];
    _matrix[row] = nullptr;
    for (auto i = row + 1; i < _rows; ++i)
      _matrix[i - 1] = _matrix[i];

    _rows--;
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  void remove_col(unsigned col) {
    if (col >= _cols)
      throw std::out_of_range("col is out of bound.");

    if (std::is_pointer<T>::value)
      for (auto i = _rows; i-- > 0;)
        Utils::pDelete(_matrix[i][col]);

    for (unsigned i = 0; i < _rows; ++i)
      for (auto j = col + 1; j < _cols; ++j)
        _matrix[i][j - 1] = _matrix[i][j];

    _cols--;
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  void reshape(unsigned rows, unsigned cols) {
    //@todo
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  void append_row(const std::initializer_list<T> &values) { insert_row(_rows, values); }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  void append_col(const std::initializer_list<T> &values) { insert_col(_cols, values); }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  void insert_row(unsigned index, const std::initializer_list<T> &values) {
    realloc(_rows + 1, _cols);
    for (auto i = index + 1; i < _rows; ++i)
      std::memcpy(_matrix[i], _matrix[i - 1], _cols * sizeof(T));

    for (unsigned i = 0; i < _cols; ++i)
      if (i >= values.size())
        _matrix[index][i] = T();
      else
        _matrix[index][i] = *(values.begin() + i);
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  void insert_col(unsigned index, const std::initializer_list<T> &values) {
    //@todo
    realloc(_rows, _cols + 1);

    for (unsigned i = 0; i < _rows; ++i)
      for (auto j = col + 1; j < _cols; ++j)
        _matrix[i][j - 1] = _matrix[i][j];
  }

private:
  T **_matrix;
  unsigned _rows;
  unsigned _cols;
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  void alloc_init() {
    _matrix = new T *[_rows];
    for (auto i = _rows; i-- > 0;)
      _matrix[i] = new T[_cols];
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  void dealloc() {
    for (auto i = _rows; i-- > 0;)
      delete[] _matrix[i];

    delete[] _matrix;
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
  void realloc(unsigned rows, unsigned cols) {
    T **tmp_matrix = new T *[rows];
    for (auto i = rows; i-- > 0;)
      tmp_matrix[i] = new T[cols];

    for (auto i = _rows; i-- > 0;)
      std::memcpy(tmp_matrix[i], _matrix[i], _cols * sizeof(T));

    dealloc();
    _rows = rows;
    _cols = cols;
    _matrix = tmp_matrix;
  }
  /***************************************************************************************************
   *
   ***************************************************************************************************/
};
/***************************************************************************************************
 *
 ***************************************************************************************************/
template <class T> inline std::ostream &operator<<(std::ostream &outs, const Matrix<T> &m) {
  return outs << "Matrix<" << typeid(T).name() << ">[" << m.rows() << "][" << m.cols() << "]";
}
/***************************************************************************************************
 *
 ***************************************************************************************************/
#endif // MATRIX_H
/***************************************************************************************************
 *
 ***************************************************************************************************/